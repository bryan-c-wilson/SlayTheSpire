# Function to check if packages are installed and install them if they are not
install_if_missing <- function(packages) {
new_packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)
}
# List of required packages
required_packages <- c("dplyr", "ggplot2", "googledrive", "googlesheets4",
"jsonlite", "lubridate", "tidyr", "tidyverse", "progress")
# Install any missing packages
install_if_missing(required_packages)
# Load the packages, does the same thing as library(each package individually) as a separate call for each and all of the packages in Required_packages
lapply(required_packages, library, character.only = TRUE)
message("Starting to load data...")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
saveRDS(data, file = "data/november.rds")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
source("~/Documents/R_Projects/Slay_The_Spire/scripts/Initialize_StS_Project_Script.R")
head(data)
# Convert event.gold_per_floor from string to list of numbers
data$event.gold_per_floor <- lapply(strsplit(data$event.gold_per_floor, ", "), as.numeric)
str(data$event.gold_per_floor)
class(data$event.gold_per_floor)
# Assuming data is your data frame
# Step 1: Convert event.gold_per_floor to character and split into lists of numeric values
data$event.gold_per_floor <- as.character(data$event.gold_per_floor)
# Assuming data is your data frame
# Step 1: Convert event.gold_per_floor to character and split into lists of numeric values
data$event.gold_per_floor <- as.character(data$event.gold_per_floor)
# Check the structure of the data frame
str(data)
# Step-by-Step Debugging and Transformation
# Step 1: Convert event.gold_per_floor to character and split into lists of numeric values
# Check the current class of the column
cat("Class of event.gold_per_floor before conversion:", class(data$event.gold_per_floor), "\n")
# Ensure the column is a character vector
data$event.gold_per_floor <- as.character(data$event.gold_per_floor)
print(colnames(data))
str(data)
# Assuming data is your data frame
# Step 1: Verify Column Names and Structure
cat("Column names in data frame:\n")
print(colnames(data))
cat("Structure of the data frame:\n")
str(data)
# Step 2: Convert event.gold_per_floor to character and split into lists of numeric values
if ("event.gold_per_floor" %in% colnames(data)) {
# Check the current class of the column
cat("Class of event.gold_per_floor before conversion:", class(data$event.gold_per_floor), "\n")
# Ensure the column is a character vector
data$event.gold_per_floor <- as.character(data$event.gold_per_floor)
# Verify conversion to character
cat("Class of event.gold_per_floor after conversion to character:", class(data$event.gold_per_floor), "\n")
# Split the character strings into lists of numeric values
data$event.gold_per_floor <- lapply(strsplit(data$event.gold_per_floor, ", "), as.numeric)
# Verify the result
str(data$event.gold_per_floor)
cat("Class of event.gold_per_floor after splitting:", class(data$event.gold_per_floor), "\n")
} else {
cat("Column 'event.gold_per_floor' not found in data frame.\n")
}
# Step 3: Convert event.is_ascension_mode to factor
if ("event.is_ascension_mode" %in% colnames(data)) {
# Check the current class of the column
cat("Class of event.is_ascension_mode before conversion:", class(data$event.is_ascension_mode), "\n")
data$event.is_ascension_mode <- as.factor(data$event.is_ascension_mode)
# Verify conversion to factor
cat("Class of event.is_ascension_mode after conversion:", class(data$event.is_ascension_mode), "\n")
} else {
cat("Column 'event.is_ascension_mode' not found in data frame.\n")
}
# Step 4: Convert event.local_time to POSIXct
if ("event.local_time" %in% colnames(data)) {
# Check the current class of the column
cat("Class of event.local_time before conversion:", class(data$event.local_time), "\n")
data$event.local_time <- as.POSIXct(data$event.local_time, format="%Y%m%d%H%M%S")
# Verify conversion to POSIXct
cat("Class of event.local_time after conversion:", class(data$event.local_time), "\n")
} else {
cat("Column 'event.local_time' not found in data frame.\n")
}
# Verify the overall changes
str(data)
total_events <- nrow(data)
print(total_events)
events_reached_floor_50 <- data %>%
filter(even.floor_reached == 50)
# Print all column names
cat("Column Names:\n")
print(colnames(data))
# Print a summary of the data
cat("\nSummary of Data:\n")
print(summary(data))
# Display the first few rows of the data
cat("\nFirst Few Rows of Data:\n")
print(head(data))
# Step 1: Convert JSON strings to lists
data$event <- lapply(data$event, fromJSON)
# Step 2: Inspect the structure of the first element
str(data$event[[1]])
# Step 3: Convert the list of nested data to a data frame
# Here, we assume that each event is structured similarly
nested_df <- bind_rows(data$event)
# Step 4: Display the column names and a summary of the nested data
cat("Column Names in Nested Data:\n")
print(colnames(nested_df))
cat("\nSummary of Nested Data:\n")
print(summary(nested_df))
cat("\nFirst Few Rows of Nested Data:\n")
print(head(nested_df))
# Step 2: Inspect the structure of the first element
str(data$event[[1]])
# Step 3: Convert the list of nested data to a data frame
# Here, we assume that each event is structured similarly
nested_df <- bind_rows(data$event)
# Step 4: Display the column names and a summary of the nested data
cat("Column Names in Nested Data:\n")
print(colnames(nested_df))
cat("\nSummary of Nested Data:\n")
print(summary(nested_df))
cat("\nFirst Few Rows of Nested Data:\n")
print(head(nested_df))
source("~/Documents/R_Projects/Slay_The_Spire/scripts/StS_Util_Script.R")
# Assuming nested_df is your data frame with flattened data
# and it contains a column named "victory"
# Check if the "victory" column exists
if ("victory" %in% colnames(nested_df)) {
# Get unique values in the "victory" column
unique_victory_values <- unique(nested_df$victory)
# Print the unique values
print(unique_victory_values)
} else {
cat("Column 'victory' not found in nested_df.\n")
}
# Assuming "victory" values that indicate a win are "TRUE"
# Adjust the condition based on the actual unique values you find
# Filter and count winning events
winning_events <- nested_df %>%
filter(victory == TRUE)  # Adjust this condition based on your unique values
total_wins <- nrow(winning_events)
cat("Total Wins:", total_wins, "\n")
total_wins / total_events
